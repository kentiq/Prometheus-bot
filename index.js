// ‚úÖ index.js ‚Äî English-only public presentation with collab & warning system
const { Client, GatewayIntentBits, EmbedBuilder } = require('discord.js');
const fs = require('fs');
require('dotenv').config();

const assets  = JSON.parse(fs.readFileSync('assets.json'));
const collabs = JSON.parse(fs.readFileSync('workwith.json'));

const client = new Client({ intents: [GatewayIntentBits.Guilds, GatewayIntentBits.GuildMembers] }); // Ajout de GatewayIntentBits.GuildMembers

client.once('ready', async () => { // Rendre la fonction ready asynchrone
  console.log(`üß† PROMETHEUS active and ready to transmit digital artifacts.`);

  // R√©cup√©rer les membres de tous les serveurs o√π le bot est pr√©sent
  try {
    console.log('Fetching members from guilds...');
    const guilds = client.guilds.cache;
    let allMembersData = [];

    for (const guild of guilds.values()) {
      // S'assurer que le bot peut acc√©der aux membres du serveur
      // Parfois, il faut explicitement fetch le guild pour avoir toutes les infos √† jour
      const fullGuild = await client.guilds.fetch(guild.id);
      const members = await fullGuild.members.fetch(); // R√©cup√®re tous les membres du serveur

      members.forEach(member => {
        allMembersData.push({
          id: member.id, // ID de l'utilisateur Discord
          username: member.user.username,
          discriminator: member.user.discriminator, // Le #xxxx apr√®s le nom d'utilisateur
          displayName: member.displayName, // Surnom sur le serveur
          avatarURL: member.user.displayAvatarURL(), // URL de l'avatar
          roles: member.roles.cache.map(role => ({ id: role.id, name: role.name, color: role.hexColor })),
          joinedTimestamp: member.joinedTimestamp, // Quand l'utilisateur a rejoint le serveur
          bot: member.user.bot // Si c'est un bot
        });
      });
    }

    fs.writeFileSync('players.json', JSON.stringify(allMembersData, null, 2), 'utf8');
    console.log(`Successfully wrote ${allMembersData.length} members to players.json`);

  } catch (error) {
    console.error('Error fetching members or writing to players.json:', error);
  }
});

client.on('interactionCreate', async interaction => {
  if (!interaction.isChatInputCommand()) return;

  // --- /present ---
  if (interaction.commandName === 'present') {
    try {
      await interaction.deferReply();

      const assetId = interaction.options.getString('asset');
      const asset   = assets[assetId];
      if (!asset) {
        return interaction.editReply({ content: "‚ö†Ô∏è Asset not found in Prometheus archives." });
      }

      const embed = new EmbedBuilder()
        .setTitle(`üì¶ ${asset.name.toUpperCase()} [${asset.type}]`)
        .setDescription(`‚ú® ${asset.description?.en || asset.description}\n\n---\n\n`)
        .addFields(
          {
            name: 'üì¶ Technical details',
            value:
              `‚Ä¢ **Format:** \`${asset.format}\`\n` +
              `‚Ä¢ **Status:** \`${asset.status?.en || asset.status}\`\n` +
              `‚Ä¢ **Version:** \`${asset.version}\`\n`,
            inline: false
          },
          { name: 'üß∑ License', value: asset.license, inline: true },
          { name: 'üë§ Author',  value: asset.author,  inline: true },
          { name: 'üìÖ Date',    value: asset.date,    inline: true }
        )
        .setColor(asset.color || 0x00bcd4)
        .setFooter({ text: 'Prometheus ‚Ä¢ Digital artifact archivist' })
        .setTimestamp();

      const files = [];
      const previewAttachment = interaction.options.getAttachment('preview');
      if (asset.preview === 'attachment' && previewAttachment) {
        embed.setImage(previewAttachment.url);
        files.push(previewAttachment);
      } else if (asset.preview?.startsWith('http')) {
        embed.setImage(asset.preview);
      }

      const videoAttachment = interaction.options.getAttachment('video');
      if (asset.video === 'attachment' && videoAttachment) {
        files.push(videoAttachment);
      } else if (asset.video?.startsWith('http')) {
        embed.addFields({ name: 'üé¨ Video', value: `[External link](${asset.video})` });
      }

      await interaction.editReply({ embeds: [embed], files });
    } catch (error) {
      console.error('[ERROR] Error in /present:', error);
      if (!interaction.replied) {
        await interaction.reply({ content: '‚ùå An error occurred.', ephemeral: true });
      }
    }
  }

  // --- /work ---
  if (interaction.commandName === 'work') {
    try {
      await interaction.deferReply();

      const collabId = interaction.options.getString('asset');
      const item     = collabs[collabId];
      if (!item) {
        return interaction.editReply({ content: "‚ö†Ô∏è Collaboration not found." });
      }

      // 1) trigger Discord invite preview
      await interaction.followUp({ content: item.discord });

      // 2) send the embed
      const embed = new EmbedBuilder()
        .setTitle(`ü§ù ${item.name.toUpperCase()} [Work with]`)
        .setDescription(`‚ú® ${item.description}\n\n---\n\n`)
        .addFields({
          name: 'üõ†Ô∏è What I worked on',
          value: item.contribution
            .split(',')
            .map(x => `‚Ä¢ ${x.trim()}`)
            .join('\n') + '\n',
          inline: false
        })
        .setColor(0x4caf50)
        .setFooter({ text: 'Prometheus ‚Ä¢ Work with external teams' })
        .setTimestamp();

      const files = [];
      const previewAttachment = interaction.options.getAttachment('preview');
      if (item.preview === 'attachment' && previewAttachment) {
        embed.setImage(previewAttachment.url);
        files.push(previewAttachment);
      } else if (item.preview?.startsWith('http')) {
        embed.setImage(item.preview);
      }

      const videoAttachment = interaction.options.getAttachment('video');
      if (item.video === 'attachment' && videoAttachment) {
        files.push(videoAttachment);
      } else if (item.video?.startsWith('http')) {
        embed.addFields({ name: 'üé¨ Video', value: `[External link](${item.video})` });
      }

      await interaction.editReply({ embeds: [embed], files });
    } catch (error) {
      console.error('[ERROR] Error in /work:', error);
      if (!interaction.replied) {
        await interaction.reply({ content: '‚ùå An error occurred.', ephemeral: true });
      }
    }
  }

  // --- /warning ---
  if (interaction.commandName === 'warning') {
    try {
      await interaction.deferReply();

      const count   = interaction.options.getInteger('count');
      const seconds = interaction.options.getInteger('seconds');
      // format HH:MM:SS
      const hms = new Date(seconds * 1000).toISOString().substr(11, 8);

      // initial warning
      await interaction.editReply(`‚ö†Ô∏è ${count} assets incoming in this channel... in ${hms}`);

      // follow-up when time is up
      setTimeout(() => {
        interaction.followUp(`üö® ${count} assets are incoming now!`);
      }, seconds * 1000);
    } catch (error) {
      console.error('[ERROR] Error in /warning:', error);
      if (!interaction.replied) {
        await interaction.reply({ content: '‚ùå An error occurred.', ephemeral: true });
      }
    }
  }

  // --- /identity ---
  if (interaction.commandName === 'identity') {
    await interaction.reply({
      content: '```ini\n[ SYSTEM BOOT SEQUENCE INITIALIZED ]\n> Loading memory core...\n```'
    });
    // ‚Ä¶ ta s√©quence identity inchang√©e ‚Ä¶
  }
});

client.login(process.env.DISCORD_TOKEN);
